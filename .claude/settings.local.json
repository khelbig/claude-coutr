{
  "permissions": {
    "allow": [
      "Bash(ls:*)",
      "Bash(cat:*)",
      "Bash(npm init:*)",
      "Bash(npm install:*)",
      "Bash(mkdir:*)",
      "Bash(git init:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(rm:*)",
      "WebFetch(domain:github.com)",
      "Bash(yarn add:*)",
      "Bash(cp:*)",
      "Bash(git restore:*)",
      "Bash(find:*)",
      "Bash(grep:*)",
      "Bash(mv:*)",
      "Bash(git revert:*)",
      "Bash(yarn lint)",
      "Bash(yarn typecheck)",
      "Bash(yarn build)",
      "Bash(curl:*)",
      "Bash(true)",
      "Bash(git checkout:*)",
      "Bash(vercel logs:*)",
      "WebFetch(domain:cloud.digitalocean.com)",
      "WebFetch(domain:operations-xp3hp.ondigitalocean.app)",
      "WebFetch(domain:operations-app-ztv7g.ondigitalocean.app)",
      "Bash(git pull:*)",
      "Bash(git rebase:*)",
      "Bash(npx eslint:*)",
      "Bash(npx prettier:*)",
      "Bash(npx tsc:*)",
      "Bash(yarn lint:*)",
      "Bash(cd ../admin)",
      "Bash(git add -A)",
      "Bash(git commit -m \"Replace loading spinner with skeleton and blur effect\n\n- Remove full-page loading spinner\n- Show page structure immediately with skeleton loaders\n- Apply blur effect to content while loading\n- Smooth transitions when data loads\n- Better perceived performance and user experience\")",
      "Bash(cd admin)",
      "Bash(git commit -m \"Add support for label_created status and capitalize all status displays\n\n- Handle label_created delivery status from Firestore  \n- Map label_created to show as ''Label Created'' in UI\n- Capitalize all status displays (payment, fulfillment, delivery, SLA)\n- Add debug logging for delivery status\n- Ensure label_created doesn''t count as shipped for SLA\")",
      "Bash(git commit -m \"Add support for label_created status and capitalize all status displays\n\n- Handle label_created delivery status from Firestore  \n- Map label_created to show as ''Label Created'' in UI\n- Capitalize all status displays (payment, fulfillment, delivery, SLA)\n- Add debug logging for delivery status\n- Ensure label_created doesn''t count as shipped for SLA\")",
      "Bash(git commit -m \"Update sync utility to handle tracking_added delivery status from Shopify\n\n- Check for delivery_status field on Shopify fulfillments\n- Check for delivery_status field on Shopify line items  \n- Default to tracking_added if tracking number exists without shipment status\n- Add console logging to help debug delivery status syncing\")",
      "Bash(npm run build:*)",
      "Bash(npx ts-node:*)",
      "Bash(touch:*)",
      "Bash(yarn eslint:*)",
      "Bash(node:*)",
      "Bash(yarn remove:*)",
      "Bash(yarn list:*)",
      "Bash(yarn tsc:*)",
      "Bash(sed:*)",
      "Bash(yarn migration:generate:*)",
      "Bash(yarn typeorm migration:generate:*)",
      "Bash(git log:*)",
      "Bash(yarn typecheck:*)",
      "Bash(python3:*)",
      "Bash(npm run typeorm:*)",
      "Bash(chmod:*)",
      "Bash(git reset:*)",
      "Bash(yarn migration:run:*)",
      "Bash(yarn backfill:*)",
      "Bash(npm run backfill:ap-invoices:*)",
      "Bash(psql:*)",
      "Bash(git clean:*)",
      "Bash(git stash:*)",
      "Bash(npx:*)",
      "Bash(yarn --version)",
      "Bash(yarn install:*)",
      "Bash(git rm:*)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/check-customer-counts.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/check-duplicate-customers.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/delete-pg-customers.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/diagnose-pg-failures.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/clean-broken-firestore-customers.ts)",
      "Bash(journalctl:*)",
      "Bash(pm2 logs:*)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node -e \"\nimport { AppDataSource } from ''./src/core/database/typeorm.config'';\nimport { SalesChannelOrder } from ''./src/entities/sales-channel-order.entity'';\nimport { SalesChannel } from ''./src/entities/sales-channel.entity'';\n\nasync function recalcWithExclusion() {\n  await AppDataSource.initialize();\n  \n  try {\n    // Get count after cleanup\n    const validOrders = await AppDataSource\n      .getRepository(SalesChannelOrder)\n      .count();\n    \n    console.log(''Valid orders in PostgreSQL after cleanup:'', validOrders);\n    \n    // Get channel metrics\n    const channel = await AppDataSource\n      .getRepository(SalesChannel)\n      .findOne({ where: { id: ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'' } });\n    \n    if (channel) {\n      console.log(''Current channel metrics:'', channel.metrics);\n      \n      // Update metrics to match actual valid orders\n      const actualOrders = await AppDataSource\n        .getRepository(SalesChannelOrder)\n        .createQueryBuilder(''sco'')\n        .where(''sco.salesChannelId = :channelId'', { channelId: channel.id })\n        .getCount();\n      \n      const totalRevenue = await AppDataSource\n        .getRepository(SalesChannelOrder)\n        .createQueryBuilder(''sco'')\n        .select(''SUM(sco.revenue)'', ''total'')\n        .where(''sco.salesChannelId = :channelId'', { channelId: channel.id })\n        .getRawOne();\n      \n      console.log(''Actual orders for this channel:'', actualOrders);\n      console.log(''Total revenue:'', totalRevenue.total);\n      \n      // Update the metrics\n      channel.metrics = {\n        ...channel.metrics,\n        totalOrders: actualOrders,\n        totalRevenue: parseFloat(totalRevenue.total || ''0''),\n        averageOrderValue: actualOrders > 0 ? parseFloat(totalRevenue.total || ''0'') / actualOrders : 0\n      };\n      \n      await AppDataSource.getRepository(SalesChannel).save(channel);\n      console.log(''Updated channel metrics:'', channel.metrics);\n    }\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\nrecalcWithExclusion().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node scripts/recalculate-sales-metrics.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 timeout 10 npx ts-node scripts/recalculate-sales-metrics.ts)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx ts-node -e \"\nimport { AppDataSource } from ''./src/core/database/typeorm.config'';\nimport { SalesChannelOrder } from ''./src/entities/sales-channel-order.entity'';\nimport { SalesChannel } from ''./src/entities/sales-channel.entity'';\n\nasync function checkResults() {\n  await AppDataSource.initialize();\n  \n  try {\n    // Get total valid orders\n    const totalOrders = await AppDataSource\n      .getRepository(SalesChannelOrder)\n      .count();\n    \n    console.log(''Total valid orders in sales_channel_orders:'', totalOrders);\n    \n    // Get the channel\n    const channel = await AppDataSource\n      .getRepository(SalesChannel)\n      .findOne({ where: { id: ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'' } });\n    \n    if (channel) {\n      console.log(''Channel metrics:'', channel.metrics);\n    }\n    \n    // Get breakdown by status\n    const statusBreakdown = await AppDataSource\n      .createQueryBuilder()\n      .select(''\"\"status\"\"'')\n      .addSelect(''COUNT(*)'', ''count'')\n      .from(SalesChannelOrder, ''sco'')\n      .where(''sco.salesChannelId = :channelId'', { channelId: ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'' })\n      .groupBy(''\"\"status\"\"'')\n      .getRawMany();\n    \n    console.log(''\\nOrder breakdown by status for this channel:'');\n    console.log(statusBreakdown);\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\ncheckResults().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\nconst { SalesChannelOrder } = require(''./dist/entities/sales-channel-order.entity.js'');\nconst admin = require(''firebase-admin'');\n\nasync function recalculate() {\n  // Initialize Firebase\n  const firebaseConfig = {\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, ''\\n''),\n  };\n  \n  if (!admin.apps.length) {\n    admin.initializeApp({\n      credential: admin.credential.cert(firebaseConfig),\n    });\n  }\n  \n  const firestore = admin.firestore();\n  \n  await AppDataSource.initialize();\n  \n  try {\n    // Clear existing order references\n    await AppDataSource\n      .createQueryBuilder()\n      .delete()\n      .from(SalesChannelOrder)\n      .execute();\n    \n    console.log(''Cleared sales_channel_orders table'');\n    \n    // Reset all channel metrics\n    await AppDataSource\n      .createQueryBuilder()\n      .update(SalesChannel)\n      .set({\n        metrics: {\n          totalOrders: 0,\n          totalRevenue: 0,\n          totalCustomers: 0,\n          averageOrderValue: 0,\n          lastOrderDate: null,\n        },\n      })\n      .execute();\n    \n    console.log(''Reset all channel metrics'');\n    \n    // Get ONLY orders that have been properly mapped with salesChannel field\n    const ordersSnapshot = await firestore.collection(''Orders'')\n      .where(''salesChannel'', ''!='', null)\n      .get();\n    \n    console.log(''Found orders with salesChannel set:'', ordersSnapshot.size);\n    \n    const channelMetrics = new Map();\n    const orderReferences = [];\n    let skippedCancelled = 0;\n    let skippedVoided = 0;\n    let skippedTest = 0;\n    \n    // Calculate metrics for each channel\n    ordersSnapshot.forEach((doc) => {\n      const orderId = doc.id;\n      const orderData = doc.data();\n      const channelId = orderData.salesChannel;\n      \n      // Skip cancelled orders and voided payments\n      const status = (orderData.fulfillment_status || orderData.status || '''').toLowerCase();\n      const paymentStatus = (orderData.financial_status || orderData.payment_status || '''').toLowerCase();\n      \n      if (status === ''cancelled'') {\n        skippedCancelled++;\n        return;\n      }\n      \n      if (paymentStatus === ''voided'') {\n        skippedVoided++;\n        return;\n      }\n      \n      // Skip test orders\n      const orderNumber = String(orderData.order_number || '''').toLowerCase();\n      if (orderNumber.includes(''test'')) {\n        skippedTest++;\n        return;\n      }\n      \n      const revenue = parseFloat(String(\n        orderData.total_price ||\n        orderData.total ||\n        orderData.subtotal_price ||\n        0\n      ));\n      \n      const customerId = orderData.customer_id || orderData.email;\n      \n      if (!channelMetrics.has(channelId)) {\n        channelMetrics.set(channelId, {\n          totalOrders: 0,\n          totalRevenue: 0,\n          customers: new Set(),\n          lastOrderDate: null,\n        });\n      }\n      \n      const metrics = channelMetrics.get(channelId);\n      metrics.totalOrders++;\n      metrics.totalRevenue += revenue;\n      if (customerId) {\n        metrics.customers.add(customerId);\n      }\n      \n      // Parse order date\n      let orderDate = new Date();\n      const dateValue = orderData.created_at;\n      if (dateValue) {\n        if (typeof dateValue.toDate === ''function'') {\n          orderDate = dateValue.toDate();\n        } else if (typeof dateValue === ''string'') {\n          orderDate = new Date(dateValue);\n        } else if (dateValue instanceof Date) {\n          orderDate = dateValue;\n        } else if (dateValue._seconds) {\n          orderDate = new Date(dateValue._seconds * 1000);\n        }\n      }\n      \n      if (!metrics.lastOrderDate || orderDate > metrics.lastOrderDate) {\n        metrics.lastOrderDate = orderDate;\n      }\n      \n      // Extract customer name\n      const customerName = orderData.shipping_address?.name || \n                          orderData.billing_address?.name || \n                          (orderData.customer?.first_name && orderData.customer?.last_name \n                            ? orderData.customer.first_name + '' '' + orderData.customer.last_name\n                            : null) ||\n                          ''Unknown Customer'';\n      \n      // Count line items\n      const itemCount = orderData.line_items?.length || 0;\n      \n      // Prepare order reference for bulk insert\n      orderReferences.push({\n        orderId,\n        orderNumber: orderData.order_number || orderId,\n        salesChannelId: channelId,\n        revenue,\n        customerId,\n        customerEmail: orderData.email,\n        customerName,\n        itemCount,\n        sourceName: orderData.source_name || orderData.sourceName,\n        orderDate,\n        status: orderData.fulfillment_status || orderData.status,\n        paymentStatus: orderData.financial_status || orderData.payment_status,\n        assignedAt: new Date(),\n      });\n    });\n    \n    console.log(''Skipped cancelled:'', skippedCancelled);\n    console.log(''Skipped voided:'', skippedVoided);\n    console.log(''Skipped test:'', skippedTest);\n    console.log(''Valid orders to insert:'', orderReferences.length);\n    \n    // Bulk insert order references\n    if (orderReferences.length > 0) {\n      const orderRepo = AppDataSource.getRepository(SalesChannelOrder);\n      \n      // Process in chunks to avoid issues\n      for (let i = 0; i < orderReferences.length; i += 50) {\n        const chunk = orderReferences.slice(i, i + 50);\n        \n        try {\n          await orderRepo.save(chunk);\n          console.log(''Saved chunk'', i / 50 + 1, ''of'', Math.ceil(orderReferences.length / 50));\n        } catch (error) {\n          console.error(''Error saving chunk:'', error.message);\n          // Try individually\n          for (const order of chunk) {\n            try {\n              await orderRepo.save(order);\n            } catch (individualError) {\n              console.error(''Failed to save order:'', order.orderNumber, individualError.message);\n            }\n          }\n        }\n      }\n      \n      console.log(''Inserted order references:'', orderReferences.length);\n    }\n    \n    // Update each channel in PostgreSQL\n    const channelRepo = AppDataSource.getRepository(SalesChannel);\n    for (const [channelId, metrics] of channelMetrics) {\n      const channel = await channelRepo.findOne({ where: { id: channelId } });\n      \n      if (!channel) {\n        console.warn(''Sales channel not found:'', channelId);\n        continue;\n      }\n      \n      channel.metrics = {\n        totalOrders: metrics.totalOrders,\n        totalRevenue: metrics.totalRevenue,\n        totalCustomers: metrics.customers.size,\n        averageOrderValue: metrics.totalOrders > 0 ? metrics.totalRevenue / metrics.totalOrders : 0,\n        lastOrderDate: metrics.lastOrderDate,\n      };\n      \n      await channelRepo.save(channel);\n      console.log(''Updated channel'', channel.name, ''with'', metrics.totalOrders, ''orders'');\n    }\n    \n    // Verify final count\n    const finalCount = await orderRepo.count();\n    console.log(''Final count in sales_channel_orders:'', finalCount);\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\nrecalculate().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\n\nasync function checkMetrics() {\n  await AppDataSource.initialize();\n  \n  try {\n    const channel = await AppDataSource\n      .getRepository(SalesChannel)\n      .findOne({ where: { id: ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'' } });\n    \n    if (channel) {\n      console.log(''Channel:'', channel.name);\n      console.log(''Metrics:'', JSON.stringify(channel.metrics, null, 2));\n    }\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\ncheckMetrics().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 npx:*)",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\nconst { SalesChannelOrder } = require(''./dist/entities/sales-channel-order.entity.js'');\nconst admin = require(''firebase-admin'');\n\nasync function recalculate() {\n  // Initialize Firebase\n  const firebaseConfig = {\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, ''\\n''),\n  };\n  \n  if (!admin.apps.length) {\n    admin.initializeApp({\n      credential: admin.credential.cert(firebaseConfig),\n    });\n  }\n  \n  const firestore = admin.firestore();\n  \n  await AppDataSource.initialize();\n  \n  try {\n    // Clear existing order references\n    await AppDataSource\n      .createQueryBuilder()\n      .delete()\n      .from(SalesChannelOrder)\n      .execute();\n    \n    console.log(''Cleared sales_channel_orders table'');\n    \n    // Reset all channel metrics\n    await AppDataSource\n      .createQueryBuilder()\n      .update(SalesChannel)\n      .set({\n        metrics: {\n          totalOrders: 0,\n          totalRevenue: 0,\n          totalCustomers: 0,\n          averageOrderValue: 0,\n          lastOrderDate: null,\n        },\n      })\n      .execute();\n    \n    console.log(''Reset all channel metrics'');\n    \n    // Get ONLY orders that have been properly mapped with salesChannel field\n    const ordersSnapshot = await firestore.collection(''Orders'')\n      .where(''salesChannel'', ''!='', null)\n      .get();\n    \n    console.log(''Found orders with salesChannel set:'', ordersSnapshot.size);\n    \n    const channelMetrics = new Map();\n    const orderReferences = [];\n    let skippedCancelled = 0;\n    let skippedVoided = 0;\n    let skippedTest = 0;\n    \n    // Calculate metrics for each channel\n    ordersSnapshot.forEach((doc) => {\n      const orderId = doc.id;\n      const orderData = doc.data();\n      const channelId = orderData.salesChannel;\n      \n      // Skip cancelled orders and voided payments\n      const status = (orderData.fulfillment_status || orderData.status || '''').toLowerCase();\n      const paymentStatus = (orderData.financial_status || orderData.payment_status || '''').toLowerCase();\n      \n      if (status === ''cancelled'') {\n        skippedCancelled++;\n        return;\n      }\n      \n      if (paymentStatus === ''voided'') {\n        skippedVoided++;\n        return;\n      }\n      \n      // Skip test orders\n      const orderNumber = String(orderData.order_number || '''').toLowerCase();\n      if (orderNumber.includes(''test'')) {\n        skippedTest++;\n        return;\n      }\n      \n      // Use total_price as selling price (what customer actually paid after discounts)\n      // This matches the admin orders dashboard calculation\n      const revenue = parseFloat(String(orderData.total_price || 0));\n      \n      const customerId = orderData.customer_id || orderData.email;\n      \n      if (!channelMetrics.has(channelId)) {\n        channelMetrics.set(channelId, {\n          totalOrders: 0,\n          totalRevenue: 0,\n          customers: new Set(),\n          lastOrderDate: null,\n        });\n      }\n      \n      const metrics = channelMetrics.get(channelId);\n      metrics.totalOrders++;\n      metrics.totalRevenue += revenue;\n      if (customerId) {\n        metrics.customers.add(customerId);\n      }\n      \n      // Parse order date\n      let orderDate = new Date();\n      const dateValue = orderData.created_at;\n      if (dateValue) {\n        if (typeof dateValue.toDate === ''function'') {\n          orderDate = dateValue.toDate();\n        } else if (typeof dateValue === ''string'') {\n          orderDate = new Date(dateValue);\n        } else if (dateValue instanceof Date) {\n          orderDate = dateValue;\n        } else if (dateValue._seconds) {\n          orderDate = new Date(dateValue._seconds * 1000);\n        }\n      }\n      \n      if (!metrics.lastOrderDate || orderDate > metrics.lastOrderDate) {\n        metrics.lastOrderDate = orderDate;\n      }\n      \n      // Extract customer name\n      const customerName = orderData.shipping_address?.name || \n                          orderData.billing_address?.name || \n                          (orderData.customer?.first_name && orderData.customer?.last_name \n                            ? orderData.customer.first_name + '' '' + orderData.customer.last_name\n                            : null) ||\n                          ''Unknown Customer'';\n      \n      // Count line items\n      const itemCount = orderData.line_items?.length || 0;\n      \n      // Prepare order reference for bulk insert\n      orderReferences.push({\n        orderId,\n        orderNumber: orderData.order_number || orderId,\n        salesChannelId: channelId,\n        revenue,\n        customerId,\n        sourceName: orderData.source_name || orderData.sourceName,\n        orderDate,\n        status: orderData.fulfillment_status || orderData.status,\n        paymentStatus: orderData.financial_status || orderData.payment_status,\n        assignedAt: new Date(),\n      });\n    });\n    \n    console.log(''Skipped cancelled:'', skippedCancelled);\n    console.log(''Skipped voided:'', skippedVoided);\n    console.log(''Skipped test:'', skippedTest);\n    console.log(''Valid orders to insert:'', orderReferences.length);\n    \n    // Bulk insert order references\n    if (orderReferences.length > 0) {\n      const orderRepo = AppDataSource.getRepository(SalesChannelOrder);\n      \n      // Process in chunks to avoid issues\n      for (let i = 0; i < orderReferences.length; i += 50) {\n        const chunk = orderReferences.slice(i, i + 50);\n        \n        try {\n          await orderRepo.save(chunk);\n          console.log(''Saved chunk'', i / 50 + 1, ''of'', Math.ceil(orderReferences.length / 50));\n        } catch (error) {\n          console.error(''Error saving chunk:'', error.message);\n          // Try individually\n          for (const order of chunk) {\n            try {\n              await orderRepo.save(order);\n            } catch (individualError) {\n              console.error(''Failed to save order:'', order.orderNumber, individualError.message);\n            }\n          }\n        }\n      }\n      \n      console.log(''Inserted order references:'', orderReferences.length);\n    }\n    \n    // Update each channel in PostgreSQL\n    const channelRepo = AppDataSource.getRepository(SalesChannel);\n    for (const [channelId, metrics] of channelMetrics) {\n      const channel = await channelRepo.findOne({ where: { id: channelId } });\n      \n      if (!channel) {\n        console.warn(''Sales channel not found:'', channelId);\n        continue;\n      }\n      \n      channel.metrics = {\n        totalOrders: metrics.totalOrders,\n        totalRevenue: metrics.totalRevenue,\n        totalCustomers: metrics.customers.size,\n        averageOrderValue: metrics.totalOrders > 0 ? metrics.totalRevenue / metrics.totalOrders : 0,\n        lastOrderDate: metrics.lastOrderDate,\n      };\n      \n      await channelRepo.save(channel);\n      console.log(''Updated channel'', channel.name, ''with'', metrics.totalOrders, ''orders, revenue:'', metrics.totalRevenue.toFixed(2));\n    }\n    \n    // Verify final count\n    const finalCount = await orderRepo.count();\n    console.log(''Final count in sales_channel_orders:'', finalCount);\n    \n    // Show the target channel metrics specifically\n    const targetChannel = await channelRepo.findOne({ where: { id: ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'' } });\n    if (targetChannel) {\n      console.log(''\\nTarget channel (Shop) metrics:'');\n      console.log(''  Total Orders:'', targetChannel.metrics.totalOrders);\n      console.log(''  Total Revenue:'', targetChannel.metrics.totalRevenue);\n      console.log(''  Average Order Value:'', targetChannel.metrics.averageOrderValue);\n    }\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\nrecalculate().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\nconst admin = require(''firebase-admin'');\n\nasync function checkTotals() {\n  // Initialize Firebase\n  const firebaseConfig = {\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, ''\\n''),\n  };\n  \n  if (!admin.apps.length) {\n    admin.initializeApp({\n      credential: admin.credential.cert(firebaseConfig),\n    });\n  }\n  \n  const firestore = admin.firestore();\n  await AppDataSource.initialize();\n  \n  try {\n    // Get actual totals from Firestore Orders collection\n    const ordersSnapshot = await firestore.collection(''Orders'').get();\n    \n    let totalRevenue = 0;\n    let totalOrders = 0;\n    let shopRevenue = 0;\n    let shopOrders = 0;\n    \n    console.log(''Total orders in Firestore:'', ordersSnapshot.size);\n    \n    ordersSnapshot.forEach((doc) => {\n      const orderData = doc.data();\n      \n      // Skip cancelled and voided\n      const status = (orderData.fulfillment_status || orderData.status || '''').toLowerCase();\n      const paymentStatus = (orderData.financial_status || orderData.payment_status || '''').toLowerCase();\n      \n      if (status === ''cancelled'' || paymentStatus === ''voided'') {\n        return;\n      }\n      \n      // Skip test orders\n      const orderNumber = String(orderData.order_number || '''').toLowerCase();\n      if (orderNumber.includes(''test'')) {\n        return;\n      }\n      \n      const revenue = parseFloat(String(orderData.total_price || 0));\n      totalRevenue += revenue;\n      totalOrders++;\n      \n      // Check if it has salesChannel set to Shop channel\n      if (orderData.salesChannel === ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'') {\n        shopRevenue += revenue;\n        shopOrders++;\n      }\n    });\n    \n    console.log(''\\nACTUAL TOTALS (excluding cancelled/voided):'');\n    console.log(''Total Orders:'', totalOrders);\n    console.log(''Total Revenue: €'', totalRevenue.toFixed(2));\n    console.log(''\\nShop Channel Only:'');\n    console.log(''Shop Orders:'', shopOrders);\n    console.log(''Shop Revenue: €'', shopRevenue.toFixed(2));\n    \n    // Now check what''s in our sales_channels table\n    const channels = await AppDataSource\n      .getRepository(SalesChannel)\n      .find();\n    \n    console.log(''\\nCURRENT METRICS IN DATABASE:'');\n    channels.forEach(channel => {\n      console.log(channel.name + '':'', {\n        orders: channel.metrics.totalOrders,\n        revenue: channel.metrics.totalRevenue\n      });\n    });\n    \n    // Check total across all channels\n    const dbTotalRevenue = channels.reduce((sum, ch) => sum + (ch.metrics.totalRevenue || 0), 0);\n    const dbTotalOrders = channels.reduce((sum, ch) => sum + (ch.metrics.totalOrders || 0), 0);\n    \n    console.log(''\\nDatabase Totals:'', {\n      orders: dbTotalOrders,\n      revenue: dbTotalRevenue\n    });\n    \n    console.log(''\\nDISCREPANCY:'');\n    console.log(''Missing Orders:'', totalOrders - dbTotalOrders);\n    console.log(''Missing Revenue: €'', (totalRevenue - dbTotalRevenue).toFixed(2));\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\ncheckTotals().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\nconst admin = require(''firebase-admin'');\n\nasync function checkTotals() {\n  // Initialize Firebase\n  const firebaseConfig = {\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, ''\\n''),\n  };\n  \n  if (!admin.apps.length) {\n    admin.initializeApp({\n      credential: admin.credential.cert(firebaseConfig),\n    });\n  }\n  \n  const firestore = admin.firestore();\n  await AppDataSource.initialize();\n  \n  try {\n    // Get actual totals from Firestore Orders collection\n    const ordersSnapshot = await firestore.collection(''Orders'').get();\n    \n    let totalRevenue = 0;\n    let totalOrders = 0;\n    let shopRevenue = 0;\n    let shopOrders = 0;\n    let ordersWithChannel = 0;\n    let ordersWithoutChannel = 0;\n    \n    console.log(''Total orders in Firestore:'', ordersSnapshot.size);\n    \n    ordersSnapshot.forEach((doc) => {\n      const orderData = doc.data();\n      \n      // Skip cancelled and voided\n      const status = (orderData.fulfillment_status || orderData.status || '''').toLowerCase();\n      const paymentStatus = (orderData.financial_status || orderData.payment_status || '''').toLowerCase();\n      \n      if (status === ''cancelled'' || paymentStatus === ''voided'') {\n        return;\n      }\n      \n      // Skip test orders\n      const orderNumber = String(orderData.order_number || '''').toLowerCase();\n      if (orderNumber.includes(''test'')) {\n        return;\n      }\n      \n      const revenue = parseFloat(String(orderData.total_price || 0));\n      totalRevenue += revenue;\n      totalOrders++;\n      \n      // Check if it has salesChannel field\n      if (orderData.salesChannel) {\n        ordersWithChannel++;\n        \n        // Check if it''s Shop channel\n        if (orderData.salesChannel === ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'') {\n          shopRevenue += revenue;\n          shopOrders++;\n        }\n      } else {\n        ordersWithoutChannel++;\n      }\n    });\n    \n    console.log(''\\nACTUAL TOTALS (excluding cancelled/voided):'');\n    console.log(''Total Valid Orders:'', totalOrders);\n    console.log(''Total Revenue: €'', totalRevenue.toFixed(2));\n    console.log(''Orders WITH salesChannel field:'', ordersWithChannel);\n    console.log(''Orders WITHOUT salesChannel field:'', ordersWithoutChannel);\n    \n    console.log(''\\nShop Channel Only:'');\n    console.log(''Shop Orders:'', shopOrders);\n    console.log(''Shop Revenue: €'', shopRevenue.toFixed(2));\n    \n    // Now check what''s in our sales_channels table\n    const channels = await AppDataSource\n      .getRepository(SalesChannel)\n      .find();\n    \n    console.log(''\\nCURRENT METRICS IN DATABASE:'');\n    channels.forEach(channel => {\n      console.log(channel.name + '':'', {\n        orders: channel.metrics.totalOrders,\n        revenue: channel.metrics.totalRevenue?.toFixed(2)\n      });\n    });\n    \n    // Check total across all channels\n    const dbTotalRevenue = channels.reduce((sum, ch) => sum + (ch.metrics.totalRevenue || 0), 0);\n    const dbTotalOrders = channels.reduce((sum, ch) => sum + (ch.metrics.totalOrders || 0), 0);\n    \n    console.log(''\\nDatabase Totals:'', {\n      orders: dbTotalOrders,\n      revenue: dbTotalRevenue.toFixed(2)\n    });\n    \n    console.log(''\\nDISCREPANCY:'');\n    console.log(''Orders with salesChannel that we track:'', ordersWithChannel);\n    console.log(''Orders in our metrics:'', dbTotalOrders);\n    console.log(''Missing orders from metrics:'', ordersWithChannel - dbTotalOrders);\n    console.log(''\\nREASON: Only'', ordersWithChannel, ''orders have salesChannel field set out of'', totalOrders, ''total valid orders'');\n    console.log(''That means'', ordersWithoutChannel, ''orders need salesChannel mapping!'');\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\ncheckTotals().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node -e \"\nconst { AppDataSource } = require(''./dist/core/database/typeorm.config.js'');\nconst { SalesChannel } = require(''./dist/entities/sales-channel.entity.js'');\n\nasync function checkChannels() {\n  await AppDataSource.initialize();\n  \n  try {\n    const channels = await AppDataSource\n      .getRepository(SalesChannel)\n      .find();\n    \n    console.log(''Sales Channels in Database:'');\n    channels.forEach(channel => {\n      console.log(''---'');\n      console.log(''ID:'', channel.id);\n      console.log(''Name:'', channel.name);\n      console.log(''Display Name:'', channel.displayName);\n      console.log(''Metrics:'', {\n        orders: channel.metrics.totalOrders,\n        revenue: channel.metrics.totalRevenue?.toFixed(2),\n        aov: channel.metrics.averageOrderValue?.toFixed(2)\n      });\n    });\n    \n    // Check which one is the Shop channel\n    const shopChannel = channels.find(ch => ch.id === ''3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff'');\n    if (shopChannel) {\n      console.log(''\\n3bff5c5d-e00b-48cd-9a3a-8e9f6f1a04ff is:'', shopChannel.name, ''('', shopChannel.displayName, '')'');\n    }\n    \n  } catch (error) {\n    console.error(''Error:'', error);\n  } finally {\n    await AppDataSource.destroy();\n  }\n}\n\ncheckChannels().catch(console.error);\n\")",
      "Bash(NODE_TLS_REJECT_UNAUTHORIZED=0 node:*)",
      "Bash(git fetch:*)",
      "Bash(git merge:*)"
    ],
    "deny": [],
    "defaultMode": "acceptEdits",
    "additionalDirectories": [
      "/Users/kenthelbig/coding"
    ]
  }
}